<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Project05 - Chat app | CS 221 - C and Systems Programming</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Project05 - Chat app" />
<meta name="author" content="Phil Peterson" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Requirements" />
<meta property="og:description" content="Requirements" />
<meta property="og:site_name" content="CS 221 - C and Systems Programming" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-12T23:29:36+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Project05 - Chat app" />
<script type="application/ld+json">
{"description":"Requirements","url":"/assignments/project05.html","@type":"BlogPosting","headline":"Project05 - Chat app","dateModified":"2022-05-12T23:29:36+00:00","datePublished":"2022-05-12T23:29:36+00:00","author":{"@type":"Person","name":"Phil Peterson"},"mainEntityOfPage":{"@type":"WebPage","@id":"/assignments/project05.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="CS 221 - C and Systems Programming" /><head>
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">  
</head>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">CS 221 - C and Systems Programming</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/help/">Getting Help</a><a class="page-link" href="/syllabus/">Syllabus</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper"><h1 class="page-heading">Project05 - Chat app</h1><div class="container">
  Due: 
  <span class="due-date">
    Wed, May 4, 2022 at 11:59 PM 
  </span>
  to <a href="https://classroom.github.com/a/GQb_harD">Github Classroom Assignment</a>
  <hr>
  <section id="main_content">
    <h2 id="requirements">Requirements</h2>

<ol>
  <li>You will develop a chat app which runs on the CSLabs Linux machines</li>
  <li>Your repo must contain a <code class="language-plaintext highlighter-rouge">Makefile</code> which generates an executable called <code class="language-plaintext highlighter-rouge">lab05</code></li>
  <li>Your app will broadcast your online presence periodically</li>
  <li>Your app will use <strong>non-blocking I/O</strong> to send and receive chat messages from other users on the network</li>
  <li>Network requirements
    <ol>
      <li>As in lab07, you will broadcast presence to the UDP broadcast address <code class="language-plaintext highlighter-rouge">10.10.13.255</code></li>
      <li>Your app will use UDP port <code class="language-plaintext highlighter-rouge">8221</code> for presence and your <a href="https://docs.google.com/spreadsheets/d/1G3YSY2todEFHKsuMHNklqIQPvGDzerM-sDQJ9T4cWMU/edit#gid=1243841982">assigned TCP port</a> for 1:1 chat messages</li>
    </ol>
  </li>
  <li>Behavior requirements
    <ol>
      <li>You must use your USF username (e.g. phpeterson) for presence and chat messages – no pseudonyms</li>
      <li>You must use the network in accordance with the USF’s <a href="https://usf.service-now.com/usf?id=usf_kb_article&amp;sys_id=49f4ed8b1bc7f890345a0dc8cc4bcb98">Technology Resources Appropriate Use Policy</a></li>
    </ol>
  </li>
</ol>

<h2 id="divide-and-conquer">Divide and Conquer</h2>

<ol>
  <li>You can reuse your client code from lab07 which broadcasts your presence using the format: <code class="language-plaintext highlighter-rouge">online phpeterson 8382</code> and <code class="language-plaintext highlighter-rouge">offline phpeterson 8382</code></li>
  <li>You can reuse your server code from lab07 and incorporate it into <code class="language-plaintext highlighter-rouge">project05</code> to accept presence messages</li>
  <li>When you know who’s online, you can create a data structure (array or linked list) which contains the username and IP address or hostname</li>
  <li>You can develop new code to use TCP sockets to send and receive chat messages</li>
  <li>You can accept user input <code class="language-plaintext highlighter-rouge">@phpeterson: do you have OH today?</code> on <code class="language-plaintext highlighter-rouge">stdin</code> using <code class="language-plaintext highlighter-rouge">poll()</code> as we will discuss in lecture.</li>
</ol>

<h2 id="boundary-conditions">Boundary Conditions</h2>

<ol>
  <li>You may assume that there are no more than 64 users online at a time</li>
  <li>You may assume that chat messages are no more than 128 characters long, and are NUL-terminated C strings</li>
</ol>

<h2 id="rubric">Rubric</h2>

<ol>
  <li>20 pts: Presence: periodic online broadcasts, offline when your app exits</li>
  <li>40 pts: Two-way 1:1 chat</li>
  <li>20 pts: Interactive grading questions</li>
  <li>10 pts: Error handling and memory management</li>
  <li>10 pts: Neatness</li>
</ol>

<h2 id="extra-credit">Extra credit</h2>

<ol>
  <li>2 pts: Add support for channels, e.g. <code class="language-plaintext highlighter-rouge">#sushi-lovers: lunch at Amiti's?</code>. Demonstrate this using multiple instances of your <code class="language-plaintext highlighter-rouge">project05</code> executable on multiple lab hosts. You may assume that all of your instances (<code class="language-plaintext highlighter-rouge">phpeterson-1</code>, <code class="language-plaintext highlighter-rouge">phpeterson-2</code>, …) are members of the <code class="language-plaintext highlighter-rouge">#sushi-lovers</code> channel</li>
</ol>

<h2 id="implementation-guide">Implementation Guide</h2>

<p><strong>Non-Blocking I/O</strong></p>
<ol>
  <li>Your program needs to process network connections and user input in a time-sliced way. You may want to use <code class="language-plaintext highlighter-rouge">scanf()</code> to get user input, but that blocks, which means network connections wouldn’t be processed.</li>
  <li>Your program should use <code class="language-plaintext highlighter-rouge">poll()</code> to do time-slicing between these activities
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
     <span class="kt">int</span>   <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* file descriptor */</span>
     <span class="kt">short</span> <span class="n">events</span><span class="p">;</span>     <span class="cm">/* requested events */</span>
     <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span>    <span class="cm">/* returned events */</span>
 <span class="p">};</span>
 <span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="n">nfds_t</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>You should write a loop which looks roughly like this:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
 <span class="kt">int</span> <span class="n">nfds</span> <span class="o">=</span> <span class="p">...;</span>
 <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">num_ready</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">num_ready</span> <span class="o">==</span> <span class="p">...)</span> 
         <span class="cm">/* do "server" things */</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>You will use a <code class="language-plaintext highlighter-rouge">pollfd</code> for your UDP broadcast socket on port 8221 and for your TCP listener on your assigned port.</li>
  <li>After you have created your <code class="language-plaintext highlighter-rouge">pollfd</code> structs, you can call <code class="language-plaintext highlighter-rouge">poll()</code> in a <code class="language-plaintext highlighter-rouge">while(!done)</code> loop</li>
  <li><code class="language-plaintext highlighter-rouge">poll()</code> returns the number of <code class="language-plaintext highlighter-rouge">pollfd</code> structs which have requested flags (<code class="language-plaintext highlighter-rouge">POLLIN</code>) set. You should loop over your <code class="language-plaintext highlighter-rouge">fdpoll</code> array and process the file descriptors which have data available (STDIN_FILENO, or UDP broadcast, or TCP chat)</li>
</ol>

<p><strong>Polling <code class="language-plaintext highlighter-rouge">STDIN_FILENO</code> for user input</strong></p>
<ol>
  <li>Since <code class="language-plaintext highlighter-rouge">stdin</code> is just a file with a file descriptor (<code class="language-plaintext highlighter-rouge">STDIN_FILENO</code>), you can read keyboard input by using a <code class="language-plaintext highlighter-rouge">pollfd</code> for <code class="language-plaintext highlighter-rouge">stdin</code> and wait for <code class="language-plaintext highlighter-rouge">POLLIN</code> events on that FD</li>
  <li><code class="language-plaintext highlighter-rouge">poll()</code> will return bits and pieces of user input typed in between timeouts</li>
  <li>You can read the <code class="language-plaintext highlighter-rouge">pollfd.fd</code> using <code class="language-plaintext highlighter-rouge">getchar()</code> or other functions</li>
  <li>You should accumulate (<code class="language-plaintext highlighter-rouge">strcat()</code>?) the bits and pieces you read in a string</li>
  <li>When the user types a <code class="language-plaintext highlighter-rouge">'\n'</code> you should write the string to the TCP socket for the recipient (client side, like the <a href="https://github.com/cs221-s22/inclass/blob/main/week14/tcp_test/tcp_test.c">TCP test app</a>)</li>
  <li>You should choose keyboard sequence to use to exit your loop. Perhaps <code class="language-plaintext highlighter-rouge">q</code> or use CTRL-D, which causes <code class="language-plaintext highlighter-rouge">getchar()</code> to return <code class="language-plaintext highlighter-rouge">EOF</code> (or -1)</li>
</ol>

<p><strong>UDP Broadcast</strong></p>
<ol>
  <li>As in lab07, you will use <code class="language-plaintext highlighter-rouge">socket()</code>, <code class="language-plaintext highlighter-rouge">setsockopt()</code> and UDP <code class="language-plaintext highlighter-rouge">sendto()</code> to broadcast your presence to the labs subnet (<code class="language-plaintext highlighter-rouge">10.10.13.255</code>) which includes all computers on the subnet listening to port <code class="language-plaintext highlighter-rouge">8221</code> (as in the given <a href="https://github.com/cs221-s22/inclass/blob/main/week13/lab-udp/client/client.c">UDP client</a>)</li>
  <li>Your project05 program will add the ability to receive new UDP messages, using the code from your lab07 server (similar to the given <code class="language-plaintext highlighter-rouge">lab-udp</code> server in the inclass repo)
    <ol>
      <li>Setup the connection using the hints, <code class="language-plaintext highlighter-rouge">getaddrinfo()</code>, and <code class="language-plaintext highlighter-rouge">bind()</code></li>
      <li>When your UDP file descriptor is ready to read, <code class="language-plaintext highlighter-rouge">poll()</code> will put the flag <code class="language-plaintext highlighter-rouge">POLLIN</code> in the <code class="language-plaintext highlighter-rouge">revents</code> of the <code class="language-plaintext highlighter-rouge">pollfd</code></li>
      <li>When that happens, you can use UDP <code class="language-plaintext highlighter-rouge">recvfrom()</code> to get the data waiting to be read (as in the given <a href="https://github.com/cs221-s22/inclass/blob/main/week13/lab-udp/server/server.c">UDP server</a>)</li>
    </ol>
  </li>
  <li>Protocol: The UDP packet should contain <code class="language-plaintext highlighter-rouge">online yourname yourport</code>. You can create this string with <code class="language-plaintext highlighter-rouge">snprintf()</code> and parse an incoming presence broadcast with <code class="language-plaintext highlighter-rouge">snscanf()</code></li>
</ol>

<p><strong>TCP Setup</strong></p>
<ol>
  <li>You will use TCP (stream) sockets to do 1:1 communication with other users.</li>
  <li>For <code class="language-plaintext highlighter-rouge">socket()</code> the domain is still <code class="language-plaintext highlighter-rouge">PF_INET</code>, the type is <code class="language-plaintext highlighter-rouge">SOCK_STREAM</code> (rather than DATAGRAM) and the protocol is <code class="language-plaintext highlighter-rouge">IPPROTO_TCP</code> (rather than UDP)</li>
  <li>You should set up a TCP listener using hints, <code class="language-plaintext highlighter-rouge">getaddrinfo()</code>, <code class="language-plaintext highlighter-rouge">socket()</code>, <code class="language-plaintext highlighter-rouge">bind()</code> and <code class="language-plaintext highlighter-rouge">listen()</code>. The socket should have <code class="language-plaintext highlighter-rouge">SO_REUSEADDR</code></li>
  <li>The socket needs to be non-blocking, which you can set up like this:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIONBIO</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>You should add the TCP file descriptor to a <code class="language-plaintext highlighter-rouge">pollfd</code> in your array of <code class="language-plaintext highlighter-rouge">pollfd</code> so the <code class="language-plaintext highlighter-rouge">poll()</code> loop can notify you when someone is trying to connect.</li>
</ol>

<p><strong>Reading from the TCP socket</strong></p>
<ol>
  <li>When the TCP listener <code class="language-plaintext highlighter-rouge">pollfd</code> has <code class="language-plaintext highlighter-rouge">revents &amp; POLLIN</code> you should <code class="language-plaintext highlighter-rouge">accept()</code> the connection, which creates a new file descriptor for the chat between you and the sending person</li>
  <li>That new file descriptor should be added to your list of <code class="language-plaintext highlighter-rouge">pollfd</code> so you can use it to send and receive messages with that user. One new FD will be created per user you chat with.</li>
</ol>

<p><strong>Writing to the TCP socket</strong></p>
<ol>
  <li>If the user types <code class="language-plaintext highlighter-rouge">@phpeterson: office hours?</code> you should lookup <code class="language-plaintext highlighter-rouge">phpeterson</code> in your list of (user, host, port)</li>
  <li>You should use hints and <code class="language-plaintext highlighter-rouge">getaddrinfo()</code> using the user’s hostname (e.g. <code class="language-plaintext highlighter-rouge">vlab21.cs.usfca.edu</code>) to create a socket, and then <code class="language-plaintext highlighter-rouge">connect()</code> to the socket:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">connect</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">);)</span>
</code></pre></div>    </div>
  </li>
  <li>When the socket has been connected, you can use TCP <code class="language-plaintext highlighter-rouge">send()</code> to transmit the user’s message to the socket:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">sent</span> <span class="o">=</span> <span class="n">send</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><strong>Keeping Track of Users</strong></p>
<ol>
  <li>In order to keep track of who is online, you may wish to build a list of users using a <code class="language-plaintext highlighter-rouge">struct</code> something like this
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">struct</span> <span class="n">user</span> <span class="p">{</span>
     <span class="kt">char</span> <span class="n">status</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span> <span class="cm">/* online or offline? */</span>
     <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>   <span class="cm">/* user name */</span>
     <span class="kt">char</span> <span class="n">port</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>   <span class="cm">/* TCP listener port */</span>
     <span class="kt">char</span> <span class="n">host</span><span class="p">[</span><span class="n">NI_MAXHOST</span><span class="p">];</span> <span class="cm">/* host name */</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>When you receive a presence message via UDP broadcast, you have the status, name, and port ready to <code class="language-plaintext highlighter-rouge">snscanf()</code></li>
  <li>You can get the hostname using <code class="language-plaintext highlighter-rouge">getnameinfo()</code> as the <a href="https://github.com/cs221-s22/inclass/blob/main/week13/lab-udp/server/server.c#L79">given UDP server does</a>.</li>
</ol>

<p><strong>Quitting the program</strong></p>
<ol>
  <li>If you catch <code class="language-plaintext highlighter-rouge">CTRL-D</code> (also known as <code class="language-plaintext highlighter-rouge">EOF</code>) when polling <code class="language-plaintext highlighter-rouge">STDIN_FILENO</code>, that can stop the <code class="language-plaintext highlighter-rouge">poll()</code> loop</li>
  <li>You can come up with an alternative, but CTRL-C does not shut down cleanly so you should not use that.</li>
  <li>When your program exits cleanly, you can broadcast offline presence and <code class="language-plaintext highlighter-rouge">close()</code> all of the <code class="language-plaintext highlighter-rouge">pollfd</code> array.</li>
</ol>

  </section>
</div>

      </div>
    </main>

  </body>

</html>
